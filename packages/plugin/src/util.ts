import * as crypto from 'crypto';
import * as fs from 'fs';
import * as path from 'path';
import { ControlledTranspileOptions } from './types/jco';

/**
 * Reads a file from disk and returns its contents as a Uint8Array.
 * @param file Path of file to read
 * @returns The file's contents as a Uint8Array
 */
export async function readFile(file: string): Promise<Uint8Array> {
  const buffer = await fs.promises.readFile(file);
  const bytes = new Uint8Array(buffer.buffer);
  return bytes;
}

/**
 * Computes the SHA-256 hash of a byte array.
 * @param bytes Byte array to hash
 * @returns SHA-256 hash as a hex string
 */
export function computeSha256(bytes: Uint8Array): string {
  const hash = crypto.createHash('sha256').update(bytes).digest('hex');
  return hash;
}

/**
 * Returns the path of the cache file for a WebAssembly component's generated bindings.
 * @param outputDir Output directory of generated bindings
 * @param name Name of WebAssembly component
 * @returns Path of cache file
 */
export function getCacheFile(outputDir: string, name: string) {
  return path.join(outputDir, `${name}.cache`);
}

/**
 * Reads the cache file for a WebAssembly component's generated bindings from disk.
 * @param outputDir Output directory of generated bindings
 * @param name Name of WebAssembly component
 * @returns Contents of cache file as a string
 */
export async function readCacheFile(outputDir: string, name: string) {
  const cacheFile = getCacheFile(outputDir, name);
  return fs.promises.readFile(cacheFile, 'utf-8').catch(() => '');
}

/**
 * Writes a hash to the cache file for a WebAssembly component's generated bindings.
 * @param outputDir Output directory of generated bindings
 * @param name Name of WebAssembly component
 * @param hash Hash to write to cache file
 */
export async function writeCacheFile(
  outputDir: string,
  name: string,
  hash: string,
) {
  const cacheFile = getCacheFile(outputDir, name);
  await fs.promises.mkdir(outputDir, { recursive: true });
  await fs.promises.writeFile(cacheFile, hash);
}

/**
 * Transforms a search parameter value into a primitive Javascript literal
 * @param value Search parameter value
 * @returns parsed Javascript literal
 */
export function searchParamToPrimitive(value: string) {
  if (value === '') return true;
  if (value === 'true') return true;
  if (value === 'false') return false;
  if (!isNaN(+value)) return +value;
  return value;
}

/**
 * Parses JCO transpile options from an import URL
 * @param url Url of a component import
 * @returns Parsed transpile options from import URL
 */
export function extractTranspileOptionsFromUrl(url: URL) {
  const searchParams = [...url.searchParams.entries()];
  return searchParams.reduce(
    (acc, [key, value]) => ({
      ...acc,
      [key]: searchParamToPrimitive(value),
    }),
    {} as ControlledTranspileOptions,
  );
}

/**
 * Decodes input as a string
 * @param input source Uint8Array or string
 * @returns decoded input as a string
 */
export function decodeAsString(input: Uint8Array | string | undefined) {
  return typeof input === 'string' ? input : new TextDecoder().decode(input);
}

/** Type representing a custom npm package for use with `createCustomPackage` */
interface CustomPackage {
  package: {
    name: string;
    private: true;
    types: string;
    exports?: Record<string, any>;
  };
  files: {
    [key: string]: Uint8Array;
  };
}

/**
 * Creates a custom package in the current node_modules directory
 * This is used to create type stubs for autogenerated bindings
 * @param detail Details of the custom package to create
 * @returns Promise that resolves when the package is created
 */
export async function createCustomPackage(detail: CustomPackage) {
  const outDir = path.resolve('./node_modules', detail.package.name);
  await fs.promises.mkdir(outDir, { recursive: true });
  for (const [name, content] of Object.entries(detail.files)) {
    await fs.promises.writeFile(path.join(outDir, name), content);
  }
  await fs.promises.writeFile(
    path.join(outDir, 'package.json'),
    JSON.stringify(detail.package, null, 2),
  );
}

export async function readCustomPackage(
  name: string,
): Promise<CustomPackage | undefined> {
  const packageDir = path.resolve('./node_modules', name);
  const packageJsonPath = path.resolve(packageDir, 'package.json');
  if (!fs.existsSync(packageJsonPath)) {
    return undefined;
  }
  const packageJson = JSON.parse(
    await fs.promises.readFile(packageJsonPath, 'utf-8'),
  );
  const files = await fs.promises.readdir(packageDir);
  const fileContents = Object.fromEntries(
    await Promise.all(
      files.map(async (file) => {
        const content = await fs.promises.readFile(path.join(packageDir, file));
        return [file, content];
      }),
    ),
  );
  return { package: packageJson, files: fileContents };
}
