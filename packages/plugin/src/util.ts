import * as crypto from 'crypto';
import * as fs from 'fs';
import * as path from 'path';
import { ControlledTranspileOptions } from './types/jco';

/**
 * Reads a file from disk and returns its contents as a Uint8Array.
 * @param file Path of file to read
 * @returns The file's contents as a Uint8Array
 */
export async function readFile(file: string): Promise<Uint8Array> {
  const buffer = await fs.promises.readFile(file);
  const bytes = new Uint8Array(buffer.buffer);
  return bytes;
}

/**
 * Computes the SHA-256 hash of a byte array.
 * @param bytes Byte array to hash
 * @returns SHA-256 hash as a hex string
 */
export function computeSha256(bytes: Uint8Array): string {
  const hash = crypto.createHash('sha256').update(bytes).digest('hex');
  return hash;
}

/**
 * Returns the path of the cache file for a WebAssembly component's generated bindings.
 * @param outputDir Output directory of generated bindings
 * @param name Name of WebAssembly component
 * @returns Path of cache file
 */
export function getCacheFile(outputDir: string, name: string) {
  return path.join(outputDir, `${name}.cache`);
}

/**
 * Reads the cache file for a WebAssembly component's generated bindings from disk.
 * @param outputDir Output directory of generated bindings
 * @param name Name of WebAssembly component
 * @returns Contents of cache file as a string
 */
export async function readCacheFile(outputDir: string, name: string) {
  const cacheFile = getCacheFile(outputDir, name);
  return fs.promises.readFile(cacheFile, 'utf-8').catch(() => '');
}

/**
 * Writes a hash to the cache file for a WebAssembly component's generated bindings.
 * @param outputDir Output directory of generated bindings
 * @param name Name of WebAssembly component
 * @param hash Hash to write to cache file
 */
export async function writeCacheFile(
  outputDir: string,
  name: string,
  hash: string,
) {
  const cacheFile = getCacheFile(outputDir, name);
  await fs.promises.mkdir(outputDir, { recursive: true });
  await fs.promises.writeFile(cacheFile, hash);
}

/**
 * Transforms a search parameter value into a primitive Javascript literal
 * @param value Search parameter value
 * @returns parsed Javascript literal
 */
export function searchParamToPrimitive(value: string) {
  if (value === '') return true;
  if (value === 'true') return true;
  if (value === 'false') return false;
  if (!isNaN(+value)) return +value;
  return value;
}

/**
 * Parses JCO transpile options from an import URL
 * @param url Url of a component import
 * @returns Parsed transpile options from import URL
 */
export function extractTranspileOptionsFromUrl(url: URL) {
  const searchParams = [...url.searchParams.entries()];
  return searchParams.reduce(
    (acc, [key, value]) => ({
      ...acc,
      [key]: searchParamToPrimitive(value),
    }),
    {} as ControlledTranspileOptions,
  );
}

/**
 * Decodes input as a string
 * @param input source Uint8Array or string
 * @returns decoded input as a string
 */
export function decodeAsString(input: Uint8Array | string | undefined) {
  return typeof input === 'string' ? input : new TextDecoder().decode(input);
}

/**
 * Creates an ambient declaration for a JS module
 * @param moduleName Name of the JS module to generate an ambient declaration fro
 * @param decl Contents of the ambient declaration
 * @returns Ambient declaration for the provided JS module name
 */
export function createModuleDeclaration(moduleName: string, decl: string) {
  return `declare module "*${moduleName}" { ${greedyMinify(decl)} }\n`;
}

/**
 * Minifies a string by removing comments and newlines
 * Not recommended for general use as it was created for a minimal use-case
 * @param input Input string to minify
 * @returns Minified string
 */
export function greedyMinify(input: string) {
  const commentsRemoved = input.replace(
    /\/\*[\s\S]*?\*\/|([^\\:]|^)\/\/.*$/gm,
    '',
  );
  const newlinesRemoved = commentsRemoved.replaceAll('\n', ' ');
  return newlinesRemoved;
}

/** Type representing a custom npm package for use with `createCustomPackage` */
interface CustomPackage {
  package: {
    name: string;
    private: true;
    types: string;
    exports?: Record<string, any>;
  };
  files: {
    [key: string]: Uint8Array;
  };
}

/**
 * Creates a custom package in the current node_modules directory
 * This is used to create type stubs for autogenerated bindings
 * @param detail Details of the custom package to create
 * @returns Promise that resolves when the package is created
 */
export function createCustomPackage(detail: CustomPackage) {
  const outDir = path.resolve('./node_modules', detail.package.name);
  fs.mkdirSync(outDir, { recursive: true });
  for (const [name, content] of Object.entries(detail.files)) {
    fs.writeFileSync(path.join(outDir, name), content);
  }
  fs.writeFileSync(
    path.join(outDir, 'package.json'),
    JSON.stringify(detail.package, null, 2),
  );
}

export function readCustomPackage(name: string): CustomPackage | undefined {
  const packageDir = path.resolve('./node_modules', name);
  const packageJsonPath = path.resolve(packageDir, 'package.json');
  if (!fs.existsSync(packageJsonPath)) return undefined;
  const packageJson = JSON.parse(fs.readFileSync(packageJsonPath, 'utf-8'));
  const files = fs.readdirSync(packageDir);
  const fileContents = Object.fromEntries(
    files.map((file) => {
      const content = fs.readFileSync(path.join(packageDir, file));
      return [file, content];
    }),
  );
  return { package: packageJson, files: fileContents };
}

export function updateCustomPackageDeclaration(
  packageName: string,
  declarationFileName: string,
  declaration: string,
) {
  const existingPackage = readCustomPackage(packageName);

  // Prefix for generated declaration
  const outputDeclarationPrefix = declaration.split('{')[0] ?? '';

  // Load any existing declarations for the package and merge with the newly generated declaration
  const mergedDeclarations = new TextEncoder().encode(
    [
      ...new TextDecoder()
        .decode(existingPackage?.files[declarationFileName])
        .split('\n')
        .filter((line) => !!line)
        .filter((line) => !line || !line.startsWith(outputDeclarationPrefix)),
      declaration,
    ].join('\n'),
  );

  // Create or update the existing custom package with the new merged declarations
  createCustomPackage({
    package: {
      private: true,
      name: packageName,
      types: declarationFileName,
    },
    files: { [declarationFileName]: mergedDeclarations },
  });
}
